import os
import json
import pandas as pd
import matplotlib.pyplot as plt
from flask import Flask, request, render_template, jsonify
from openai import OpenAI
from dotenv import load_dotenv  # Load environment variables from .env
import re

# Load API key from .env file
load_dotenv()
api_key = os.getenv("OPENAI_API_KEY")

# Check if API key exists
if not api_key:
    raise ValueError("‚ùå Missing OpenAI API key! Add it to your .env file.")

# Initialize OpenAI client
client = OpenAI(api_key=api_key)

app = Flask(__name__)
UPLOAD_FOLDER = 'uploads'
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

# Store session memory
session_memory = {
    "last_uploaded_file": None,
    "chat_history": []
}

@app.route('/chat', methods=['POST'])
    
def chat():
    user_message = request.json.get('message', '').strip()

    # Handle natural language plot requests
    if "plot" in user_message.lower():
        return handle_plot_request(user_message)

    # Otherwise, let GPT handle the conversation
    return jsonify({"response": chat_with_gpt(user_message)})

def chat_with_gpt(user_message):
    """Sends a message to GPT and returns its response."""
    session_memory["chat_history"].append({"role": "user", "content": user_message})

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are an AI assistant that helps users analyze data and generate plots."},
            *session_memory["chat_history"]
        ],
        temperature=0.5
    )

    bot_reply = response.choices[0].message.content.strip()
    session_memory["chat_history"].append({"role": "assistant", "content": bot_reply})

    return bot_reply

def handle_plot_request(user_message):
    """Handles natural language plot requests and executes GPT-generated Matplotlib code."""
    if not session_memory["last_uploaded_file"]:
        return jsonify({"response": "I need a CSV file before I can create a plot. Please upload one first."})

    # Generate Python code for the plot from GPT
    generated_code = ask_gpt_for_python_code(user_message)

    # Execute the code safely
    success, error_message = run_python_code(generated_code)

    if success:
        return jsonify({"response": "Here is your plot!", "image_url": "/static/plot.png"})
    else:
        return jsonify({"response": f"Failed to generate plot. Error: {error_message}"})

def ask_gpt_for_python_code(user_message):
    """Asks GPT to generate Matplotlib code based on natural language input."""
    system_message = {
        "role": "system",
        "content": f"""
        You are an AI that converts natural language descriptions into executable Matplotlib Python code.
        - Assume the dataset is a Pandas DataFrame named 'df'.
        - Assume the data has been loaded from the last uploaded CSV file.
        - DO NOT include markdown, explanations, or comments‚Äîonly pure executable Python code.
        - Always save the figure to 'static/plot.png'.

        Example:

        User input: "Plot a histogram of payment_value and title it 'Payments Distribution'."
        Response:
        import matplotlib.pyplot as plt
        df['payment_value'].plot(kind='hist', bins=30, edgecolor='black')
        plt.title('Payments Distribution')
        plt.savefig('static/plot.png')
        plt.close()
        """
    }

    user_message_obj = {"role": "user", "content": user_message}

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[system_message, user_message_obj],
        temperature=0
    )

    # Extract only the Python code (remove markdown formatting)
    raw_code = response.choices[0].message.content.strip()
    raw_code = raw_code.replace("```python", "").replace("```", "").strip()

    return raw_code

def run_python_code(code):
    """Runs the Python code generated by GPT and handles errors."""
    try:
        # üîπ Replace 'df' with actual dataset from uploaded file
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], session_memory["last_uploaded_file"])
        df = pd.read_csv(filepath)

        # üîπ Execute the cleaned code in a controlled environment
        exec(code, {"df": df, "plt": plt})

        return True, None  # Success
    except Exception as e:
        return False, str(e)  # Failure

@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({'error': 'No file part'})
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No selected file'})

    filepath = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
    file.save(filepath)

    session_memory["last_uploaded_file"] = file.filename
    return jsonify({'response': f"File '{file.filename}' uploaded successfully! You can now ask me about its contents or request plots."})

@app.route('/')
def index():
    return render_template('index.html')

if __name__ == '__main__':
    app.run(debug=True)
